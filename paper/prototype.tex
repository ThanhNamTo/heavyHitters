\section{Prototype in P4}
\label{sec:prototype}
To show that our algorithms are implementable in modern programmable switch languages, we implemented Front Rejection and Back Rejection in P4 version 1.1~\cite{p4lang} by modifying the P4 implementation of HashPipe~\cite{p4code}. The HashPipe implementation of P4 uses a custom hash function with P4's \verb+modify_field_with_hash_based_offset()+ to hash each IP source address to an index of a hash table, which is implemented as a stateful register in the switch. The HashPipe implementation also uses metadata to track the carried key and count throughout each stage. We use this setup for each of our stages as well.

To implement Front Rejection, on the first stage we use P4's random number generator, \verb+modify_field_rng_uniform()+, to generate an index. To implement our placement probability $p = 1 / (5*log(c_m + 1))$, where $c_m$ is the count at the randomly generated index, we do two things. As the logarithm function cannot be implemented with P4's basic bitwise functions and inability to loop, we first approximate logarithm into 16 ``buckets'' with sizes ranging from 1 to nearly 100,000 as the change per step decreases. For example, $c_m = 16-20$ ranges from $p=0.1625-0.1513$, and are consolidated into a bucket with value 16. We confirmed that these buckets have nearly identical results by running each of our simulations, discussed in the next section, with the approximate logarithm function. We then generate a second random integer between 0 and 100 and compare it to our approximate logarithm value: if the random integer is greater we keep the current value and otherwise we replace it. In the second and subsequent stages, we use the same implementation as HashPipe. We implemented this with only two stages, as all additional stages would be a duplicate of stage 2.

We created two implementations of Back Rejection. In both implementations' first stage, we save the hashed index of the original packet in our metadata. In the first version, to avoid doing a second loop, we create an additional stage. This stage revisits the original hashed index in stage 1's table and replaces it with probability $p = 1 / (5*log(c_m + 1))$ using the same method discussed above. Though we did not encounter any issues with the second access of stage 1's table registers, we were uncertain if this would cause issues in some hardware. Thus, in our second version we recirculate the packet. In the final stage of the first loop, we indicate in the metadata that it has completed a first pass and use P4's \verb+resubmit()+ function to place it back on the ingress pipeline. To prevent the packet from traversing through all stages, we take advantage of P4's match:action structure to assure it only goes through the additional stage mentioned in the first version. While recirculation can effectively halve the available packet-processing bandwidth, we believe the impact is less since only one stage is completed twice. This impact could also potentially be avoided altogether with the first version. We implemented both versions with only three stages, as all additional stages would be a duplicate of stage 2.

All three switch implementations have been successfully compiled and brought up on a Mininet~\cite{mininet} instance, but due to complications with the Mininet connections were unable to run with simulated traffic. While simulation of traffic would confirm proper function of each implementation, it would be impossible to exactly match simulation results due to our inability to perfectly mock P4's random number generator. These implementations still confirm that our algorithms can be implemented with programmable hardware today.

